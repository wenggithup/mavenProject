### 1、ThreadLocal原理以及优缺点？
# ThreadLocal是线程Thread中属性threadLocals的管理者。ThreadLocal是各线程将值存在该线程的
#  map集合中，ThreadLocal自身作为key，需要用时获得该线程之前存入的值，只对线程的名称和值有作用
#  实质上并不能解决并发问题，解决多线程操作变量的安全问题。

### 2、如何决定选用 HashMap 还是 TreeMap
#      需要比较存储顺序的时候用TreeMap，增加创建的时候用TreeMap；
#      不需要比较顺序时用Hashmap，由于底层是哈希表，由链表和数组或红黑树组成，所以查询极快；

### 3、final、finally、finalize三者区别
##  final是关键字：
#  可以用来修饰变量，如果用来修饰基本数据类型，那么该数据永远不能被重新赋值，如果修饰对象，那么该对象永远不能用来接收其它对象
#  可以用来修饰类，表示该类不能被继承，并且默认该类的所有方法都是final修饰的方法
#  可以用来修饰方法，表示该方法永远不能被重写，可以写多个final重载的方法
## finally
#  使用时与try或者try catch一起使用，除非虚拟机停止否则永远会执行finally代码块，且执行顺序在try之前；
## finaize
#  垃圾回收器将要回收对象时，最后判定使用的方法，但是此方法具有不确定性，不一定执行完

###4、写出冒泡排序和选择排序，以及二分法查找 注意:首先搞清楚原理，然后自己写出代码
#  见代码

### 5、HashMap和Hashtable各有什么特点，它们有什么区别？ 注意:从用法上、数据安全等方面考虑
#  HashMap底层是哈希表，无序、key唯一，线程不安全，键值都可以为null；
#  Hastable无序、key值唯一，键值不可以为null，线程安全

### 6、你对Java中的volatile关键字了解多少？尝试写出代码去验证
#  Java语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，volatil是轻量级锁，占用内存较小
#  能保证内存可见、但是不保证原子性、并且禁止指令重新排序

### 7、什么是数据库的三大范式
#  第一范式（1NF）：列不可再分，强调数据表的原子性
#  第二范式（2NF）：要求表中所有的列，都必须依赖主键，而不能有任何一列与主键没关系，也就是一张表只描述一件事情
#  第三范式（3NF）：表中的每一列只与主键直接相关而不是间接相关

### 8、有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的
#  LinkedHashMap，linkedhashmap底层借助哈希桶+双向链表，就是在hashmap的基础上通过双向链表维护元素节点间的顺序；

### 9、ArrayList和LinkList各自的特点和区别 注意:从数据存储、性能、数据访问等方面来考虑
#  ArrayList底层是数组，查询块，增删较慢，线程不安全
#  LinkList底层是链表，增删块，查询蛮，线程不安全

### 10、ClassLoader和Class.forName()这两个有什么区别？了解NIO嘛?尝试分析NIO并且以代码举例
#  都可以用来对类加载，ClassLoader只将class文件加载到jvm中，Class.forName()不仅将class文件
#  加载到jvm中，还会对类进行解释，执行类中的static块   


